{"version":3,"sources":["algorithm/Node.ts","components/Result.tsx","components/SentenceAnagram.tsx","algorithm/utils.ts","components/WordAnagram.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Node","letter","final","depth","childrens","letters","node","this","chars","toLowerCase","forEach","char","index","undefined","length","minWordSize","tiles","replaceAll","minLength","anagrams","path","root","word","join","Object","entries","count","Result","props","useState","isSentenceResults","filterPermutations","setFilterPermutations","minMaxWordLength","setMinMaxWordLength","contains","setContains","startWith","setStartWith","diplayedAnagrams","uniques","Set","map","sentence","split","sort","filter","find","includes","startsWith","htmlFor","type","id","value","onChange","e","parseInt","target","onClick","a","i","newRoot","SentenceAnagram","MAX_RESULTS","setSentence","minWordLength","setMinWordLength","setAnagrams","useEffect","dictionary","add","searchAnagrams","iterable","anagram","current","next","results","done","push","elements","generator","isDone","preventDefault","onSubmit","name","autoFocus","searchNextAnagrams","wordToSortedCharacters","wordToCharacterMap","Map","character","get","set","WordAnagram","characters","setCharacters","useAllCharacters","setUseAllCharacters","dictionaryMap","setDictionaryMap","charactersMaps","setCharactersMaps","key","charactersMap","wordToSearch","characterMap","words","biggerMap","mapIsSubsetOf","trim","checked","baseName","document","querySelector","getAttribute","App","isLoading","setIsLoading","setDictionary","fetch","process","then","r","text","body","entry","basename","className","to","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.f53e2398.chunk.js","sourcesContent":["// Source: https://prograide.com/pregunta/46535/algorithme-pour-generer-des-anagrammes\n\nexport class Node {\n    static newRoot(): Node {\n        return new Node('', false, 0);\n    }\n\n    constructor(public readonly letter: string,\n                public final: boolean,\n                public readonly depth: number,\n                public childrens: { [k in string]: Node } = {}) {\n    }\n\n    public add(letters: string): void {\n        let node: Node = this;\n        const chars = [...letters.toLowerCase()];\n        chars.forEach((char, index) => {\n            if (node.childrens[char] === undefined) {\n                node.childrens[char] = new Node(char, index === chars.length - 1, index + 1)\n            }\n            node = node.childrens[char];\n        });\n    }\n\n    public anagram(letters: string, minWordSize = 3): Generator<string> {\n        const tiles: { [k in string]: number } = {};\n        const chars = [...letters.replaceAll(' ', '').toLowerCase()];\n        chars.forEach((char) => {\n            tiles[char] = (tiles[char] || 0) + 1\n        });\n        const minLength = chars.length;\n        return this.anagrams(tiles, [], this, minLength, minWordSize);\n    }\n\n    private* anagrams(tiles: { [p: string]: number }, path: string[], root: Node, minLength: number, minWordSize: number): Generator<string> {\n        if (this.final && this.depth >= minWordSize) {\n            const word = path.join('');\n            const length = word.replaceAll(' ', '').length;\n            if (length >= minLength) {\n                yield word;\n            }\n            for (const word of root.anagrams(tiles, [...path, ' '], root, minLength, minWordSize)) {\n                yield word;\n            }\n        }\n        for (const [letter, node] of Object.entries(this.childrens)) {\n            const count = tiles[letter] || 0;\n            if (count === 0) {\n                continue;\n            }\n            tiles[letter] = count - 1;\n            for (const word of node.anagrams(tiles, [...path, letter], root, minLength, minWordSize)) {\n                yield word;\n            }\n            tiles[letter] = count;\n        }\n    }\n}\n","import React, {useState} from \"react\";\n\nexport interface Props {\n    anagrams: string[]\n    isSentenceResults: boolean\n}\nexport const Result: React.FC<Props> = (props) => {\n    const [filterPermutations, setFilterPermutations] = useState(props.isSentenceResults);\n    const [minMaxWordLength, setMinMaxWordLength] = useState(5);\n    const [contains, setContains] = useState(\"\");\n    const [startWith, setStartWith] = useState(\"\");\n\n    let diplayedAnagrams = props.anagrams;\n    if (filterPermutations) {\n        const uniques = new Set(props.anagrams.map(sentence => sentence.split(\" \").sort().join(\" \")));\n        diplayedAnagrams = [...uniques];\n    }\n    diplayedAnagrams = diplayedAnagrams\n        .filter(sentence => sentence.split(\" \").find(word => word.length >= minMaxWordLength))\n    diplayedAnagrams = diplayedAnagrams\n        .filter(sentence => sentence.includes(contains));\n    diplayedAnagrams = diplayedAnagrams\n        .filter(sentence => sentence.split(\" \").find(word => word.startsWith(startWith)));\n\n    return (<>\n        <h4>{diplayedAnagrams.length} résultat(s)</h4>\n        <div>\n            {props.isSentenceResults && <div>\n                <label htmlFor=\"minMaxWordLength\">Taille minimale du mot le plus long</label>\n                <input type=\"number\" id=\"minMaxWordLength\" value={minMaxWordLength} onChange={(e) => setMinMaxWordLength(parseInt(e.target.value))}/>\n            </div>}\n            <div>\n                <label htmlFor=\"contains\">Contient</label>\n                <input type=\"text\" id=\"contains\" value={contains} onChange={(e) => setContains(e.target.value)}/>\n            </div>\n            <div>\n                <label htmlFor=\"startWith\">A un mot qui commence par</label>\n                <input type=\"text\" id=\"startWith\" value={startWith} onChange={(e) => setStartWith(e.target.value)}/>\n            </div>\n            {filterPermutations ?\n                <button onClick={() => setFilterPermutations(false)}>Ne pas filtrer les permutations</button> :\n                <button onClick={() => setFilterPermutations(true)}>Filtrer les permutations</button>\n            }\n        </div>\n        <ul>\n            {diplayedAnagrams.map((a, i) => <li key={i}>{a}</li>)}\n        </ul>\n    </>)\n};\n","import React, {useEffect, useState} from \"react\";\nimport {Node} from \"../algorithm/Node\";\nimport {Result} from \"./Result\";\n\nconst node = Node.newRoot();\n\nexport interface IterationState {\n    generator: Generator<string>\n    elements: string[]\n    isDone: boolean\n}\n\nexport interface Props {\n    dictionary: string[]\n}\n\nexport const SentenceAnagram: React.FC<Props> = (props) => {\n    const MAX_RESULTS = 5_000;\n    const [sentence, setSentence] = useState(\"bon courage\");\n    const [minWordLength, setMinWordLength] = useState(3);\n    const [anagrams, setAnagrams] = useState<IterationState | null>(null);\n\n    useEffect(() => {\n        props.dictionary.forEach(word => {\n            node.add(word);\n        })\n    }, [props.dictionary]);\n\n    const searchAnagrams = (e: React.FormEvent<HTMLFormElement> | React.MouseEvent<HTMLButtonElement>) => {\n        let iterable = node.anagram(sentence, minWordLength);\n        let current = iterable.next();\n        let results = [];\n        let count = 0;\n        while (!current.done && count < MAX_RESULTS) {\n            results.push(current.value);\n            current = iterable.next();\n            count = count + 1;\n        }\n        setAnagrams({\n            elements: results,\n            generator: iterable,\n            isDone: !!current.done\n        })\n        e.preventDefault();\n    };\n\n    const searchNextAnagrams = (anagrams: IterationState) => {\n        let current = anagrams.generator.next();\n        let results = [];\n        let count = 0;\n        while (!current.done && count < MAX_RESULTS) {\n            results.push(current.value);\n            current = anagrams.generator.next();\n            count = count + 1;\n        }\n        setAnagrams({\n            elements: results,\n            generator: anagrams.generator,\n            isDone: !!current.done\n        })\n    }\n\n    return (<>\n        <h1>Anagrammes de phrases</h1>\n        <form onSubmit={searchAnagrams}>\n            <div>\n                <label htmlFor=\"sentence\">Phrase</label>\n                <input type=\"text\" name=\"sentence\" autoFocus={true} value={sentence} onChange={(e) => setSentence(e.target.value)}/>\n            </div>\n            <div>\n                <label htmlFor=\"minWordLength\">Taille minimale des mots</label>\n                <input type=\"number\" id=\"minWordLength\" value={minWordLength} onChange={(e) => setMinWordLength(parseInt(e.target.value))}/>\n            </div>\n            <button onClick={searchAnagrams}>Rechercher les anagrammes</button>\n        </form>\n        { anagrams && !anagrams.isDone ? (<>\n            Il y a plus de {MAX_RESULTS} résultats\n            <button onClick={() => searchNextAnagrams(anagrams)}>charger les résultats suivants</button></>\n        ) : null}\n        { anagrams ? <Result anagrams={anagrams.elements} isSentenceResults={true} /> : null}\n    </>);\n}\n","export function wordToSortedCharacters(word: string): string {\n    return word.split(\"\").sort().join(\"\");\n}\n\nexport function wordToCharacterMap(word: string): Map<string, number> {\n    const map = new Map<string, number>();\n    for (const character of word.split(\"\")) {\n        const count = map.get(character) || 0;\n        map.set(character, count + 1);\n    }\n    return map;\n}\n\nexport function mapIsSubsetOf(map: Map<string, number>, biggerMap: Map<string, number>): boolean {\n    for (const [key, value] of map.entries()) {\n        const biggerCount = biggerMap.get(key) || 0;\n        if (value > biggerCount) {\n            return false;\n        }\n    }\n    return true;\n}\n","import React, {useEffect, useState} from \"react\";\nimport {Result} from \"./Result\";\nimport {mapIsSubsetOf, wordToCharacterMap, wordToSortedCharacters} from \"../algorithm/utils\";\n\nexport interface Props {\n    dictionary: string[]\n}\n\nexport const WordAnagram: React.FC<Props> = (props) => {\n    const [characters, setCharacters] = useState(\"SENTTERFUELNEEMANANNITTERIZFRDAVEIOELOESUQAEULVC\");\n    const [useAllCharacters, setUseAllCharacters] = useState(true);\n    const [anagrams, setAnagrams] = useState<string[]>([]);\n    const [dictionaryMap, setDictionaryMap] = useState<Map<string, string[]>>(new Map());\n    const [charactersMaps, setCharactersMaps] = useState<{word: string, charactersMap: Map<string, number>}[]>([]);\n\n    useEffect(() => {\n        const map = new Map<string, string[]>();\n        const charactersMaps: {word: string, charactersMap: Map<string, number>}[] = [];\n        props.dictionary.forEach(word => {\n            const key = wordToSortedCharacters(word);\n            const anagrams = map.get(key) || [];\n            map.set(key, [...anagrams, word]);\n            charactersMaps.push({word: word, charactersMap: wordToCharacterMap(word)});\n        });\n        setDictionaryMap(map);\n        setCharactersMaps(charactersMaps);\n    }, [props.dictionary]);\n\n    const searchAnagrams = (e: React.FormEvent<HTMLFormElement> | React.MouseEvent<HTMLButtonElement>) => {\n        const wordToSearch = characters.toLowerCase().replaceAll(/\\s/g, '');\n        if (useAllCharacters) {\n            setAnagrams(dictionaryMap.get(wordToSortedCharacters(wordToSearch)) || []);\n        } else {\n            const characterMap = wordToCharacterMap(wordToSearch);\n            const words = charactersMaps\n                .filter(({word, charactersMap}) => mapIsSubsetOf(charactersMap, characterMap))\n                .map(({word}) => word);\n            setAnagrams(words);\n        }\n        e.preventDefault();\n    }\n\n    return (<>\n        <h1>Anagrammes de mots</h1>\n        <form onSubmit={searchAnagrams}>\n            <div>\n                <label htmlFor=\"characters\">Charactères</label>\n                <input type=\"text\" name=\"characters\" autoFocus={true} value={characters}\n                       onChange={(e) => setCharacters(e.target.value.trim())}/>\n            </div>\n            <div>\n                <label htmlFor=\"useAllCharacters\">Utiliser tous les charactères</label>\n                <input type=\"checkbox\" name=\"useAllCharacters\" checked={useAllCharacters}\n                       onChange={(e) => setUseAllCharacters(!useAllCharacters)}/>\n            </div>\n            <button onClick={searchAnagrams}>Rechercher les anagrammes</button>\n        </form>\n        <Result anagrams={anagrams} isSentenceResults={false}/>\n    </>)\n};\n","import React, {useEffect, useState} from 'react';\nimport './App.css';\nimport {SentenceAnagram} from \"./components/SentenceAnagram\";\nimport {Link, Route, Switch, BrowserRouter as Router} from \"react-router-dom\";\nimport {WordAnagram} from \"./components/WordAnagram\";\n\nconst baseName = document.querySelector('base')?.getAttribute('href') || undefined;\nfunction App() {\n    const [isLoading, setIsLoading] = useState(true);\n    const [dictionary, setDictionary] = useState<string[]>([]);\n\n    useEffect(() => {\n        setIsLoading(true);\n        fetch(process.env.PUBLIC_URL + \"/data/dictionary_fr.txt\")\n            .then(r => r.text())\n            .then(body => body.split(\"\\n\"))\n            .then(entries => {\n                const dictionary = entries.map(entry => entry.replaceAll(\"\\r\", \"\"));\n                setDictionary(dictionary);\n                setIsLoading(false);\n            });\n    }, []);\n    return (\n        <Router basename={baseName}>\n            <nav className=\"container\">\n                <div>\n                    <Link to=\"/\">Anagrammes de phrase</Link>\n                    <Link to=\"/words\">Anagrammes de mots</Link>\n                </div>\n            </nav>\n            {isLoading ? <p>Chargement du dictionnaire...</p> : <div className=\"App\">\n                <Switch>\n                    <Route path=\"/words\">\n                        <WordAnagram dictionary={dictionary} />\n                    </Route>\n                    <Route path=\"/\">\n                        <SentenceAnagram dictionary={dictionary}/>\n                    </Route>\n                </Switch>\n            </div>}\n        </Router>\n    );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}